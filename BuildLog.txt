12 May 2019

Laid out initial "framework" for a USB Manager class.  This class will mainly act as a shim between IOKit.USB and the low-level C driver libraries (librtlsdr).  

The primary reason for this shim is to allow for dynamic removal / addition of RTLSDR dongles without the need to restart the application or using a "refresh" button.  The rtlsdr library only captures a "snapshot" of the attached dongles at any given time with no way of knowing when devices are added or removed, so therefore, the USBManger class will monitor for device plugins and removals and then call delegate functions for the main application to determine if the USB device is an SDR and act accordingly.

The USB manager consists of 3 source files.  The first file is a simple structure that describes a USB device using its USB VID, PID, Vendor, Product, Serial, as well as its IOKit registry ID for matching removals.  The next file, io_object_t+IOUSBDevice.swift creates several extensions for io_object_t.  io_object_t is nothing more than a UInt, but by extending its type, it allows for OO access to IOKit data about that object.  For example: deviceName = ioObject.ioRegistryName().  The last, and main file, contains the delegate and class definitions for the USB Manager.

The IOUSBManager class is a singleton which creates a one-to-one listing of the USB devices as recognized from IOKit (All devices on the USB plane of the IORegistry).  This class creates an IOKit notification when any USB device is attached or removed, updates its internal array, then calls the appropriate added or removed delegate.  The commit contains working a working IOUSBManager class.  The rest of the application needs to be re-factored to be able to accept dynamic addition and removals of USB devices.  (This class may not need to be a singleton, which will be determined as I further integrate it into the main application)
 

1 May 2019

Converted sidebar view controller to individualized disclosable controllers.  The original sidebar controller changed the current view based on the selected item of the drop down controller (which listed each sidebar view available.)  As I start to add new view controllers for changing as many options as possible, it will be beneficial to have multiple views visible simultaneously.

Originally, each sidebar view was swapped in and out as selected by the dropdown selection.  With the new layout, a new "DisclosureViewController" class was created which is then subclassed by all of the sidebar view controllers.  The disclosure controller superclass contains all the code needed to present the controller title with a "Show" / "Hide" button.  Clicking on the button will toggle the view's .isHidden property.  This is something that can be animated and will be revisited in the future.

The SidebarViewController takes its array of children (view controllers) as initialized by the MainWindowController, and places their views within a stack view such that all elements (views) of the array are visible simultaneously.  The main sidebar view will need to be placed into a NSScrollView at some future point as the number of sidebar controllers are increased.

The disclosure buttons will be changed at some point to match more closely the buttons that appear / disappear in Xcode (and other Apple apps.)

The current .isHidden status of each view controller will be a "NSDefault" such that their states will be kept for the next launch / execution.

The DisclosureViewController is a from scratch Swift creation loosely based off Apple's "InfoBarStackView" example. 





